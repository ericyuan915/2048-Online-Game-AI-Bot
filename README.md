# 2048-Online-Game-AI-Bot

# Project Report
In this project, I implemented an Expectimax search algorithm to find the relatively most optimal move given a 2048 game board. 
I started with the function NextMove, which served to call the core functions maximize1 (grid, depth) and chance(grid, depth).  Before I touched on this core search algorithm, I would like to introduce my other helper functions briefly first. To support the search function, I implemented the canMoveUp/Down/Left/Right functions at the beginning. These functions serve to check if there was a neighboring empty tile or a neighboring same number tile. One thing to note is that we would consider grid [[2,2,0,0][0,0,0,0] [0,0,0,0] [0,0,0,0]] cannot move up because even if it moves up, nothing will change but a 2 or 4 will appear in a random tile. We would certainly consider it as a non-optimal move, since nothing has been merged and the number of empty tiles decreased. Hence, my searched branch will not consider such a “waste” move while searching. Next, I used nested loops to implement the move functions: up/down/right/left. They were similar among themselves, with different loops to handle different cases. Within them, we firstly made a copy of the current grid by using deepcopy() function to not really “move” the grid but to “search” in the branches of the tree. 
Then I implemented the search function. I will discuss my heuristics function later. In my maximize1(grid, depth), my stopping condition was that either we finished all of our stipulated depth or the grid could not move in any direction anymore (game over). Next, I found all the possible moves for the current grid. For each move, I called the chance function, which served to calculate the expectation of the move. The expectation was equal to the sum of each future grid’s heuristics multiplied by the number’s (2 or 4) appearing probability divided by the number of available tiles. The stopping condition for the chance function was that either the stipulated depth was reached or there was no more available empty tile to insert a new number into the grid. Then we shift back to the maximize1 function. If the calculated utility was bigger than before, then we updated the maxUtility and the corresponding move direction. Finally, the relatively most optimal move was returned by the function. 
I was updating my heuristics function nonstop to improve performance. We have two main features for the heuristics function: sum of the current numbers of the grid + number of empty tiles of the grid. Each of them was multiplied by a weight to indicate their distinct significances. The sum of the numbers is the most important one. The bigger number we achieved, the better score we got. Hence, it was the most important one to consider. The second important one was the number of empty tiles. The game over condition was that the grid cannot move in any direction anymore since all the tiles were filled up and no merge was possible. Hence, we wanted more empty tiles on the grid. In the end, I assigned weights to my grid numbers and the two features. The weights for the grid numbers were in a snake shape, so that when we moved the grid, more merges could occur. I also experimented with the normal shape and the snake shape, and the latter performed better. Apparently, the upper left corner had the biggest weight, so that we would expect a big number like 2048 staying at the corner to save more space and more frequent merges for small numbers on the other side. The different heuristics were assigned different weights too. The number of empty tiles is also important. To make it count in the final total utility, we multiplied it with a weight that had similar scale to the after-weighting sum of numbers on the gird. I was experimenting with different weights for the two features I utilized by keeping submitting for testing performance. I finally found that 2^15 -- 2^0 snake weights for the numbers on the grid and 2^12 for the number of empty tiles had the best performance for the heuristics function. 
I mainly managed to optimize my heuristic function, rather than the search speed. So far, I could reach depth 3 at most. No matter how I improved the program speed, depth 4 still could not be reached. I would also say this was my biggest challenge. I first tried to reduce the number of loops in the code, and the run time was improved a little bit. I printed out the time cost of every function. It seemed deepcopy() function cost the most time with roughly 5 seconds per call. I changed my canMove() function from using deepcopy() to the current one without using. Then I tried to change all my list of list to NumPy array because the floating-point calculation is faster than integer calculation. However, the result turned out to be a little slower than expected, which was strange. I tried early quit as well, by setting the upper limit to 4096 (in comment of NextMove function). Whenever the grid reached 4096, the game automatically ended. This would only help with the speed of the cases that reached 4096, but not the others. The search speed could not be much improved, and the next depth could not be reached either. To conclude, the heuristics function was my biggest optimization, and search time was my biggest challenge.
My final game score is 2969.6 and the execution time is roughly 2.5 minutes. I would actually explore this program more in my future free time to further improve its performance. I enjoyed the game itself and the process of exploring and improving my own algorithm, which played the game more and more smartly.
